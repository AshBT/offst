use crypto::identity::{PublicKey, Signature};
use crypto::uid::Uid;
use crypto::hash::HashResult;
use crypto::crypto_rand::RandValue;

use crate::funder::messages::FriendsRoute;
use crate::funder::report::FunderReportMutation;


/// IndexClient -> IndexServer
#[derive(Debug)]
pub struct RequestRoutes {
    pub request_id: Uid,
    /// Wanted capacity for the route. 
    /// 0 means we want to optimize for capacity??
    pub capacity: u128,
    pub source: PublicKey,
    pub destination: PublicKey,
    /// This directed edge must not show up in the route.
    /// Useful for finding non trivial directed loops.
    pub opt_exclude: Option<(PublicKey, PublicKey)>,
}

#[derive(Debug)]
pub struct RouteWithCapacity {
    pub route: FriendsRoute,
    pub capacity: u128,
}

/// IndexServer -> IndexClient
#[derive(Debug)]
pub struct ResponseRoutes {
    pub request_id: Uid,
    pub routes: Vec<RouteWithCapacity>,
}

#[derive(Debug, Clone)]
pub struct UpdateFriend {
    /// Friend's public key
    pub public_key: PublicKey,
    /// To denote remote requests closed, assign 0 to sendCapacity
    pub send_capacity: u128,
    /// To denote local requests closed, assign 0 to recvCapacity
    pub recv_capacity: u128,
}


/// IndexClient -> IndexServer
#[derive(Debug, Clone)]
pub enum Mutation {
    UpdateFriend(UpdateFriend),
    RemoveFriend(PublicKey),
}

#[derive(Debug, Clone)]
pub struct MutationsUpdate {
    /// Public key of the node sending the mutations.
    pub node_public_key: PublicKey,
    /// List of mutations to relationships with direct friends.
    pub mutations : Vec<Mutation>,
    /// A time hash (Given by the server previously). 
    /// This is used as time, proving that this message was signed recently.
    pub time_hash: HashResult,
    /// A randomly generated sessionId. The counter is related to this session Id.
    pub session_id: Uid,
    /// Incrementing counter, making sure that mutations are received in the correct order.
    /// For a new session, the counter should begin from 0 and increment by 1 for every MutationsUpdate message.
    /// When a new connection is established, a new sesionId should be randomly generated.
    pub counter: u64,
    /// Rand nonce, used as a security measure for the next signature.
    pub rand_nonce: RandValue,
    /// signature(sha_512_256("MUTATIONS_UPDATE") || 
    ///           nodePublicKey ||
    ///           mutation || 
    ///           timeHash || 
    ///           counter || 
    ///           randNonce)
    pub signature: Signature,
}

#[derive(Debug, Clone)]
pub struct TimeProofLink {
    /// List of hashes that produce a certain hash
    /// sha_512_256("HASH_CLOCK" || hashes)
    pub hashes: Vec<HashResult>,
}

#[derive(Debug, Clone)]
pub struct ForwardMutationsUpdate {
    pub mutations_update: MutationsUpdate,
    /// A proof that MutationsUpdate was signed recently
    /// Receiver should verify:
    /// - sha_512_256(hashes[0]) == MutationsUpdate.timeHash,
    /// - For all i < n - 1 : hashes[i][index[i]] == sha_512_256(hashes[i+1])
    /// - hashes[n-1][index[n-1]] is some recent time hash generated by the receiver.
    pub time_proof_chain: Vec<TimeProofLink>,
}

#[derive(Debug)]
pub enum IndexServerToClient {
    TimeHash(HashResult),
    ResponseRoutes(ResponseRoutes),
}


#[derive(Debug)]
pub enum IndexClientToServer {
    MutationsUpdate(MutationsUpdate),
    RequestRoutes(RequestRoutes),
}


#[derive(Debug)]
pub enum IndexServerToServer {
    TimeHash(HashResult),
    ForwardMutationsUpdate(ForwardMutationsUpdate),
}


// ---------------------------------------------------
// IndexClient <--> AppServer communication
// ---------------------------------------------------

#[derive(Debug)]
/// ISA stands for Index Server Address
pub struct IndexClientReport<ISA> {
    /// A list of trusted index servers.
    index_servers: Vec<ISA>,
    /// The server we are currently connected to (None if not connected).
    connected_server: Option<ISA>,
}

#[derive(Debug)]
pub enum IndexClientReportMutation<ISA> {
    AddIndexServer(ISA),
    RemoveIndexServer(ISA),
    SetConnectedServer(Option<ISA>),
}


// TODO: We need to add a separate ResponseRoutes struct for the interface between 
// IndexClient and AppServer. It should be different than the ResponseRoutes between index client
// and server.
//
// The IndexClient <-> AppServer ResponseRoutes should be able to fail, and have an internal enum:

/*
pub enum ResponseRoutesResult {
    Success(Vec<RouteWithCapacity>),
    Failure,
}

#[derive(Debug)]
pub struct ResponseRoutes {
    pub request_id: Uid,
    pub result: ResponseRoutesResult,
}
*/

#[derive(Debug)]
pub enum IndexClientToAppServer<ISA> {
    ReportMutations(Vec<IndexClientReportMutation<ISA>>),
    ResponseRoutes(ResponseRoutes),
}

#[derive(Debug)]
pub enum AppServerToIndexClient<ISA,A> {
    AddIndexServer(ISA),
    RemoveIndexServer(ISA),
    RequestRoutes(RequestRoutes),
    FunderReportMutations(Vec<FunderReportMutation<A>>),
}

